{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "408711e2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Paquetes\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from sklearn.linear_model import LassoCV\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import StandardScaler\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "853423b9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# FUNCIONES\n",
    "def mape(y_true, y_pred):\n",
    "    y_true = np.array(y_true)\n",
    "    eps = 1e-8\n",
    "    return np.mean(np.abs((y_true - y_pred) / (y_true + eps))) * 100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "be83c793",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Datos cargados: (38, 50)\n"
     ]
    }
   ],
   "source": [
    "# CARGAR DATOS\n",
    "df_csv = pd.read_csv(r\"C:/Users/irwin/Downloads/Sin_GZ.csv\")\n",
    "print(\"Datos cargados:\", df_csv.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "3ed322e4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Tipos de datos tras limpieza:\n",
      "POLIZA                   object\n",
      "SUBRAMO                   int64\n",
      "INCISO                    int64\n",
      "SINIESTRO                object\n",
      "VIGENCIA                 object\n",
      "TIPO DE VEHICULO         object\n",
      "MARCA VEHICULO           object\n",
      "DESCRIPCION VEHICULO     object\n",
      "MODELO                    int64\n",
      "SERIE VEHICULO           object\n",
      "ESTADO                   object\n",
      "POBLACIÓN                object\n",
      "FECHA DE SINIESTRO        int64\n",
      "AÑO                       int64\n",
      "MES                      object\n",
      "DÍA                      object\n",
      "RANGO_HORA               object\n",
      "FECHA DE REPORTE          int64\n",
      "FECHA CIERRE             object\n",
      "ESTATUS                  object\n",
      "NOMBRE CONDUCTOR         object\n",
      "TIPO PERDIDA             object\n",
      "CAUSA DETALLADA          object\n",
      "RESPONSABILIDAD          object\n",
      "COBERTURA AFECTADA       object\n",
      "CDR                      object\n",
      "RED                      object\n",
      "TIPO TALLER/AGENCIA     float64\n",
      "RESERVA                 float64\n",
      "AJUSTES                 float64\n",
      "PAGO                    float64\n",
      "DEDUCIBLE                 int64\n",
      "RECUPERACION              int64\n",
      "SALVAMENTO                int64\n",
      "GASTOS                  float64\n",
      "COSTO NETO TOTAL        float64\n",
      "RVA DISPONIBLE          float64\n",
      "CNS_DM                    int64\n",
      "CNS_RT                    int64\n",
      "CNS_GM                    int64\n",
      "CNS_RC                  float64\n",
      "CNS_OTROS                 int64\n",
      "RVA_DM                    int64\n",
      "RVA_RT                    int64\n",
      "RVA_RC                  float64\n",
      "RVA_GM                    int64\n",
      "RVA_OTROS                 int64\n",
      "RANGO TERMINO            object\n",
      "CONTADOR                  int64\n",
      "RANGO MONTO              object\n",
      "dtype: object\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
      "C:\\Users\\irwin\\AppData\\Local\\Temp\\ipykernel_1956\\3860877197.py:11: FutureWarning: errors='ignore' is deprecated and will raise in a future version. Use to_numeric without passing `errors` and catch exceptions explicitly instead\n",
      "  df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n"
     ]
    }
   ],
   "source": [
    "# LIMPIEZA DE COLUMNAS TIPO TEXTO\n",
    "for col in df_csv.columns:\n",
    "    if df_csv[col].dtype == 'object':\n",
    "        df_csv[col] = (\n",
    "            df_csv[col]\n",
    "            .astype(str)\n",
    "            .str.replace(',', '', regex=False)\n",
    "            .str.replace('$', '', regex=False)\n",
    "            .str.replace('%', '', regex=False)\n",
    "        )\n",
    "        df_csv[col] = pd.to_numeric(df_csv[col], errors='ignore')\n",
    "\n",
    "print(\"Tipos de datos tras limpieza:\")\n",
    "print(df_csv.dtypes)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "81ad3fee",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Variables numéricas: ['SUBRAMO', 'INCISO', 'MODELO', 'FECHA DE SINIESTRO', 'AÑO', 'FECHA DE REPORTE', 'TIPO TALLER/AGENCIA', 'RESERVA', 'AJUSTES', 'PAGO', 'DEDUCIBLE', 'RECUPERACION', 'SALVAMENTO', 'GASTOS', 'COSTO NETO TOTAL', 'RVA DISPONIBLE', 'CNS_DM', 'CNS_RT', 'CNS_GM', 'CNS_RC', 'CNS_OTROS', 'RVA_DM', 'RVA_RT', 'RVA_RC', 'RVA_GM', 'RVA_OTROS', 'CONTADOR']\n"
     ]
    }
   ],
   "source": [
    "# VARIABLES NUMÉRICAS\n",
    "num_vars = df_csv.select_dtypes(include=[np.number]).columns.tolist()\n",
    "print(\"\\nVariables numéricas:\", num_vars)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "f2fd1acb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Dimensiones de X: (38, 26)\n"
     ]
    }
   ],
   "source": [
    "# DEFINIR X Y Y (VARIABLE DEPENDIENTE)\n",
    "\n",
    "y = df_csv['COSTO NETO TOTAL']  # variable que quieres predecir\n",
    "\n",
    "X = df_csv[num_vars].copy()\n",
    "\n",
    "# remover Y de X para evitar fuga de información\n",
    "\n",
    "X = X.drop(columns=['COSTO NETO TOTAL'])\n",
    "\n",
    "print(\"\\nDimensiones de X:\", X.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "0f275390",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Datos restantes después de quitar NA: (0, 26)\n"
     ]
    }
   ],
   "source": [
    "# QUITAR NULOS\n",
    "\n",
    "data = pd.concat([X, y], axis=1).dropna()\n",
    "X = data.drop(columns=['COSTO NETO TOTAL'])\n",
    "y = data['COSTO NETO TOTAL']\n",
    "\n",
    "print(\"\\nDatos restantes después de quitar NA:\", X.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "fb5c2150",
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "With n_samples=0, test_size=0.2 and train_size=None, the resulting train set will be empty. Adjust any of the aforementioned parameters.",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mValueError\u001b[39m                                Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[8]\u001b[39m\u001b[32m, line 3\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# TRAIN / TEST SPLIT\u001b[39;00m\n\u001b[32m----> \u001b[39m\u001b[32m3\u001b[39m X_train, X_test, y_train, y_test = \u001b[43mtrain_test_split\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m      4\u001b[39m \u001b[43m    \u001b[49m\u001b[43mX\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43my\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mtest_size\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m0.2\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mrandom_state\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m38\u001b[39;49m\n\u001b[32m      5\u001b[39m \u001b[43m)\u001b[49m\n",
      "\u001b[36mFile \u001b[39m\u001b[32mc:\\Users\\irwin\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\sklearn\\utils\\_param_validation.py:218\u001b[39m, in \u001b[36mvalidate_params.<locals>.decorator.<locals>.wrapper\u001b[39m\u001b[34m(*args, **kwargs)\u001b[39m\n\u001b[32m    212\u001b[39m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[32m    213\u001b[39m     \u001b[38;5;28;01mwith\u001b[39;00m config_context(\n\u001b[32m    214\u001b[39m         skip_parameter_validation=(\n\u001b[32m    215\u001b[39m             prefer_skip_nested_validation \u001b[38;5;129;01mor\u001b[39;00m global_skip_validation\n\u001b[32m    216\u001b[39m         )\n\u001b[32m    217\u001b[39m     ):\n\u001b[32m--> \u001b[39m\u001b[32m218\u001b[39m         \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mfunc\u001b[49m\u001b[43m(\u001b[49m\u001b[43m*\u001b[49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    219\u001b[39m \u001b[38;5;28;01mexcept\u001b[39;00m InvalidParameterError \u001b[38;5;28;01mas\u001b[39;00m e:\n\u001b[32m    220\u001b[39m     \u001b[38;5;66;03m# When the function is just a wrapper around an estimator, we allow\u001b[39;00m\n\u001b[32m    221\u001b[39m     \u001b[38;5;66;03m# the function to delegate validation to the estimator, but we replace\u001b[39;00m\n\u001b[32m    222\u001b[39m     \u001b[38;5;66;03m# the name of the estimator by the name of the function in the error\u001b[39;00m\n\u001b[32m    223\u001b[39m     \u001b[38;5;66;03m# message to avoid confusion.\u001b[39;00m\n\u001b[32m    224\u001b[39m     msg = re.sub(\n\u001b[32m    225\u001b[39m         \u001b[33mr\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mparameter of \u001b[39m\u001b[33m\\\u001b[39m\u001b[33mw+ must be\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    226\u001b[39m         \u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mparameter of \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mfunc.\u001b[34m__qualname__\u001b[39m\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m must be\u001b[39m\u001b[33m\"\u001b[39m,\n\u001b[32m    227\u001b[39m         \u001b[38;5;28mstr\u001b[39m(e),\n\u001b[32m    228\u001b[39m     )\n",
      "\u001b[36mFile \u001b[39m\u001b[32mc:\\Users\\irwin\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\sklearn\\model_selection\\_split.py:2919\u001b[39m, in \u001b[36mtrain_test_split\u001b[39m\u001b[34m(test_size, train_size, random_state, shuffle, stratify, *arrays)\u001b[39m\n\u001b[32m   2916\u001b[39m arrays = indexable(*arrays)\n\u001b[32m   2918\u001b[39m n_samples = _num_samples(arrays[\u001b[32m0\u001b[39m])\n\u001b[32m-> \u001b[39m\u001b[32m2919\u001b[39m n_train, n_test = \u001b[43m_validate_shuffle_split\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m   2920\u001b[39m \u001b[43m    \u001b[49m\u001b[43mn_samples\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mtest_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mtrain_size\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdefault_test_size\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m0.25\u001b[39;49m\n\u001b[32m   2921\u001b[39m \u001b[43m\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   2923\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m shuffle \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28;01mFalse\u001b[39;00m:\n\u001b[32m   2924\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m stratify \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
      "\u001b[36mFile \u001b[39m\u001b[32mc:\\Users\\irwin\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\sklearn\\model_selection\\_split.py:2499\u001b[39m, in \u001b[36m_validate_shuffle_split\u001b[39m\u001b[34m(n_samples, test_size, train_size, default_test_size)\u001b[39m\n\u001b[32m   2496\u001b[39m n_train, n_test = \u001b[38;5;28mint\u001b[39m(n_train), \u001b[38;5;28mint\u001b[39m(n_test)\n\u001b[32m   2498\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m n_train == \u001b[32m0\u001b[39m:\n\u001b[32m-> \u001b[39m\u001b[32m2499\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\n\u001b[32m   2500\u001b[39m         \u001b[33m\"\u001b[39m\u001b[33mWith n_samples=\u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[33m, test_size=\u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[33m and train_size=\u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[33m, the \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m   2501\u001b[39m         \u001b[33m\"\u001b[39m\u001b[33mresulting train set will be empty. Adjust any of the \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m   2502\u001b[39m         \u001b[33m\"\u001b[39m\u001b[33maforementioned parameters.\u001b[39m\u001b[33m\"\u001b[39m.format(n_samples, test_size, train_size)\n\u001b[32m   2503\u001b[39m     )\n\u001b[32m   2505\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m n_train, n_test\n",
      "\u001b[31mValueError\u001b[39m: With n_samples=0, test_size=0.2 and train_size=None, the resulting train set will be empty. Adjust any of the aforementioned parameters."
     ]
    }
   ],
   "source": [
    "# TRAIN / TEST SPLIT\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split(\n",
    "    X, y, test_size=0.2, random_state=38\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "26af228d",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'X_train' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[9]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# ESCALAR DATOS\u001b[39;00m\n\u001b[32m      3\u001b[39m scaler = StandardScaler()\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m X_train_scaled = scaler.fit_transform(\u001b[43mX_train\u001b[49m)\n\u001b[32m      5\u001b[39m X_test_scaled = scaler.transform(X_test)\n",
      "\u001b[31mNameError\u001b[39m: name 'X_train' is not defined"
     ]
    }
   ],
   "source": [
    "# ESCALAR DATOS\n",
    "\n",
    "scaler = StandardScaler()\n",
    "X_train_scaled = scaler.fit_transform(X_train)\n",
    "X_test_scaled = scaler.transform(X_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "5826e8f3",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'X_train_scaled' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[10]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# LASSO CV\u001b[39;00m\n\u001b[32m      3\u001b[39m lasso = LassoCV(cv=\u001b[32m5\u001b[39m, random_state=\u001b[32m42\u001b[39m, n_jobs=-\u001b[32m1\u001b[39m)\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m lasso.fit(\u001b[43mX_train_scaled\u001b[49m, y_train)\n\u001b[32m      6\u001b[39m y_pred_lasso = lasso.predict(X_test_scaled)\n",
      "\u001b[31mNameError\u001b[39m: name 'X_train_scaled' is not defined"
     ]
    }
   ],
   "source": [
    "# LASSO CV\n",
    "\n",
    "lasso = LassoCV(cv=5, random_state=42, n_jobs=-1)\n",
    "lasso.fit(X_train_scaled, y_train)\n",
    "\n",
    "y_pred_lasso = lasso.predict(X_test_scaled)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "a56fb025",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'y_test' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[11]\u001b[39m\u001b[32m, line 2\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# MÉTRICAS LASSO\u001b[39;00m\n\u001b[32m----> \u001b[39m\u001b[32m2\u001b[39m mse_l = mean_squared_error(\u001b[43my_test\u001b[49m, y_pred_lasso)\n\u001b[32m      3\u001b[39m rmse_l = np.sqrt(mse_l)\n\u001b[32m      4\u001b[39m mae_l = mean_absolute_error(y_test, y_pred_lasso)\n",
      "\u001b[31mNameError\u001b[39m: name 'y_test' is not defined"
     ]
    }
   ],
   "source": [
    "# MÉTRICAS LASSO\n",
    "mse_l = mean_squared_error(y_test, y_pred_lasso)\n",
    "rmse_l = np.sqrt(mse_l)\n",
    "mae_l = mean_absolute_error(y_test, y_pred_lasso)\n",
    "mape_l = mape(y_test, y_pred_lasso)\n",
    "r2_l = r2_score(y_test, y_pred_lasso)\n",
    "\n",
    "print(\"\\nLASSOCV (alpha=%.4f)\" % lasso.alpha_)\n",
    "print(\"MAE: %.4f, RMSE: %.4f, MAPE: %.2f%%, R2: %.4f\" %\n",
    "      (mae_l, rmse_l, mape_l, r2_l))\n",
    "\n",
    "coef_df = pd.Series(lasso.coef_, index=X.columns).sort_values(key=abs, ascending=False)\n",
    "print(\"\\nTop coef Lasso:\")\n",
    "print(coef_df.head(10))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "17da8672",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'X_train' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[12]\u001b[39m\u001b[32m, line 4\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# RANDOM FOREST\u001b[39;00m\n\u001b[32m      3\u001b[39m rf = RandomForestRegressor(n_estimators=\u001b[32m300\u001b[39m, random_state=\u001b[32m42\u001b[39m, n_jobs=-\u001b[32m1\u001b[39m)\n\u001b[32m----> \u001b[39m\u001b[32m4\u001b[39m rf.fit(\u001b[43mX_train\u001b[49m, y_train)\n\u001b[32m      6\u001b[39m y_pred_rf = rf.predict(X_test)\n",
      "\u001b[31mNameError\u001b[39m: name 'X_train' is not defined"
     ]
    }
   ],
   "source": [
    "# RANDOM FOREST\n",
    "\n",
    "rf = RandomForestRegressor(n_estimators=300, random_state=42, n_jobs=-1)\n",
    "rf.fit(X_train, y_train)\n",
    "\n",
    "y_pred_rf = rf.predict(X_test)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "150cc166",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'y_test' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[13]\u001b[39m\u001b[32m, line 3\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# MÉTRICAS RF\u001b[39;00m\n\u001b[32m----> \u001b[39m\u001b[32m3\u001b[39m mse_rf = mean_squared_error(\u001b[43my_test\u001b[49m, y_pred_rf)\n\u001b[32m      4\u001b[39m rmse_rf = np.sqrt(mse_rf)\n\u001b[32m      5\u001b[39m mae_rf = mean_absolute_error(y_test, y_pred_rf)\n",
      "\u001b[31mNameError\u001b[39m: name 'y_test' is not defined"
     ]
    }
   ],
   "source": [
    "# MÉTRICAS RF\n",
    "\n",
    "mse_rf = mean_squared_error(y_test, y_pred_rf)\n",
    "rmse_rf = np.sqrt(mse_rf)\n",
    "mae_rf = mean_absolute_error(y_test, y_pred_rf)\n",
    "mape_rf = mape(y_test, y_pred_rf)\n",
    "r2_rf = r2_score(y_test, y_pred_rf)\n",
    "\n",
    "print(\"\\nRandomForest:\")\n",
    "print(\"MAE: %.4f, RMSE: %.4f, MAPE: %.2f%%, R2: %.4f\" %\n",
    "      (mae_rf, rmse_rf, mape_rf, r2_rf))\n",
    "\n",
    "imp = pd.Series(rf.feature_importances_, index=X.columns).sort_values(ascending=False)\n",
    "print(\"\\nTop importancias RF:\")\n",
    "print(imp.head(10))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "28758caf",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'mae_l' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[14]\u001b[39m\u001b[32m, line 5\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# GUARDAR RESULTADOS\u001b[39;00m\n\u001b[32m      3\u001b[39m results = pd.DataFrame({\n\u001b[32m      4\u001b[39m     \u001b[33m'\u001b[39m\u001b[33mmodel\u001b[39m\u001b[33m'\u001b[39m: [\u001b[33m'\u001b[39m\u001b[33mLasso\u001b[39m\u001b[33m'\u001b[39m, \u001b[33m'\u001b[39m\u001b[33mRandomForest\u001b[39m\u001b[33m'\u001b[39m],\n\u001b[32m----> \u001b[39m\u001b[32m5\u001b[39m     \u001b[33m'\u001b[39m\u001b[33mMAE\u001b[39m\u001b[33m'\u001b[39m: [\u001b[43mmae_l\u001b[49m, mae_rf],\n\u001b[32m      6\u001b[39m     \u001b[33m'\u001b[39m\u001b[33mRMSE\u001b[39m\u001b[33m'\u001b[39m: [rmse_l, rmse_rf],\n\u001b[32m      7\u001b[39m     \u001b[33m'\u001b[39m\u001b[33mMAPE\u001b[39m\u001b[33m'\u001b[39m: [mape_l, mape_rf],\n\u001b[32m      8\u001b[39m     \u001b[33m'\u001b[39m\u001b[33mR2\u001b[39m\u001b[33m'\u001b[39m: [r2_l, r2_rf]\n\u001b[32m      9\u001b[39m })\n\u001b[32m     11\u001b[39m results.to_csv(\u001b[33m\"\u001b[39m\u001b[33msupervised_results_summary.csv\u001b[39m\u001b[33m\"\u001b[39m, index=\u001b[38;5;28;01mFalse\u001b[39;00m)\n\u001b[32m     12\u001b[39m coef_df.to_csv(\u001b[33m\"\u001b[39m\u001b[33mlasso_coefficients.csv\u001b[39m\u001b[33m\"\u001b[39m)\n",
      "\u001b[31mNameError\u001b[39m: name 'mae_l' is not defined"
     ]
    }
   ],
   "source": [
    "# GUARDAR RESULTADOS\n",
    "\n",
    "results = pd.DataFrame({\n",
    "    'model': ['Lasso', 'RandomForest'],\n",
    "    'MAE': [mae_l, mae_rf],\n",
    "    'RMSE': [rmse_l, rmse_rf],\n",
    "    'MAPE': [mape_l, mape_rf],\n",
    "    'R2': [r2_l, r2_rf]\n",
    "})\n",
    "\n",
    "results.to_csv(\"supervised_results_summary.csv\", index=False)\n",
    "coef_df.to_csv(\"lasso_coefficients.csv\")\n",
    "imp.to_csv(\"rf_feature_importances.csv\")\n",
    "\n",
    "print(\"\\nArchivos guardados correctamente.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5c03c7fb",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
